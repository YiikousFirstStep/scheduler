// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task.proto

#ifndef PROTOBUF_task_2eproto__INCLUDED
#define PROTOBUF_task_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace schedule {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_task_2eproto();
void protobuf_AssignDesc_task_2eproto();
void protobuf_ShutdownFile_task_2eproto();

class TimeSegment;
class Task;
class Schedule;
class Tasks;
class Schedules;

enum Schedules_FinalStatus {
  Schedules_FinalStatus_SUCCESS = 0,
  Schedules_FinalStatus_INCOMPLETE = 1
};
bool Schedules_FinalStatus_IsValid(int value);
const Schedules_FinalStatus Schedules_FinalStatus_FinalStatus_MIN = Schedules_FinalStatus_SUCCESS;
const Schedules_FinalStatus Schedules_FinalStatus_FinalStatus_MAX = Schedules_FinalStatus_INCOMPLETE;
const int Schedules_FinalStatus_FinalStatus_ARRAYSIZE = Schedules_FinalStatus_FinalStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* Schedules_FinalStatus_descriptor();
inline const ::std::string& Schedules_FinalStatus_Name(Schedules_FinalStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    Schedules_FinalStatus_descriptor(), value);
}
inline bool Schedules_FinalStatus_Parse(
    const ::std::string& name, Schedules_FinalStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Schedules_FinalStatus>(
    Schedules_FinalStatus_descriptor(), name, value);
}
// ===================================================================

class TimeSegment : public ::google::protobuf::Message {
 public:
  TimeSegment();
  virtual ~TimeSegment();

  TimeSegment(const TimeSegment& from);

  inline TimeSegment& operator=(const TimeSegment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeSegment& default_instance();

  void Swap(TimeSegment* other);

  // implements Message ----------------------------------------------

  TimeSegment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeSegment& from);
  void MergeFrom(const TimeSegment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 duration = 1;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 1;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // optional int32 cool_down = 2 [default = 0];
  inline bool has_cool_down() const;
  inline void clear_cool_down();
  static const int kCoolDownFieldNumber = 2;
  inline ::google::protobuf::int32 cool_down() const;
  inline void set_cool_down(::google::protobuf::int32 value);

  // optional int32 deadline = 3;
  inline bool has_deadline() const;
  inline void clear_deadline();
  static const int kDeadlineFieldNumber = 3;
  inline ::google::protobuf::int32 deadline() const;
  inline void set_deadline(::google::protobuf::int32 value);

  // repeated int32 earliest_starts = 4;
  inline int earliest_starts_size() const;
  inline void clear_earliest_starts();
  static const int kEarliestStartsFieldNumber = 4;
  inline ::google::protobuf::int32 earliest_starts(int index) const;
  inline void set_earliest_starts(int index, ::google::protobuf::int32 value);
  inline void add_earliest_starts(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      earliest_starts() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_earliest_starts();

  // repeated int32 latest_starts = 5;
  inline int latest_starts_size() const;
  inline void clear_latest_starts();
  static const int kLatestStartsFieldNumber = 5;
  inline ::google::protobuf::int32 latest_starts(int index) const;
  inline void set_latest_starts(int index, ::google::protobuf::int32 value);
  inline void add_latest_starts(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      latest_starts() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_latest_starts();

  // optional int32 priority = 6 [default = 10];
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 6;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:schedule.TimeSegment)
 private:
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_cool_down();
  inline void clear_has_cool_down();
  inline void set_has_deadline();
  inline void clear_has_deadline();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 duration_;
  ::google::protobuf::int32 cool_down_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > earliest_starts_;
  ::google::protobuf::int32 deadline_;
  ::google::protobuf::int32 priority_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > latest_starts_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TimeSegment* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string group = 2;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline const ::std::string& group() const;
  inline void set_group(const ::std::string& value);
  inline void set_group(const char* value);
  inline void set_group(const char* value, size_t size);
  inline ::std::string* mutable_group();
  inline ::std::string* release_group();
  inline void set_allocated_group(::std::string* group);

  // repeated string pre_req_ids = 3;
  inline int pre_req_ids_size() const;
  inline void clear_pre_req_ids();
  static const int kPreReqIdsFieldNumber = 3;
  inline const ::std::string& pre_req_ids(int index) const;
  inline ::std::string* mutable_pre_req_ids(int index);
  inline void set_pre_req_ids(int index, const ::std::string& value);
  inline void set_pre_req_ids(int index, const char* value);
  inline void set_pre_req_ids(int index, const char* value, size_t size);
  inline ::std::string* add_pre_req_ids();
  inline void add_pre_req_ids(const ::std::string& value);
  inline void add_pre_req_ids(const char* value);
  inline void add_pre_req_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pre_req_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pre_req_ids();

  // optional .schedule.TimeSegment time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::schedule::TimeSegment& time() const;
  inline ::schedule::TimeSegment* mutable_time();
  inline ::schedule::TimeSegment* release_time();
  inline void set_allocated_time(::schedule::TimeSegment* time);

  // @@protoc_insertion_point(class_scope:schedule.Task)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* group_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pre_req_ids_;
  ::schedule::TimeSegment* time_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class Schedule : public ::google::protobuf::Message {
 public:
  Schedule();
  virtual ~Schedule();

  Schedule(const Schedule& from);

  inline Schedule& operator=(const Schedule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Schedule& default_instance();

  void Swap(Schedule* other);

  // implements Message ----------------------------------------------

  Schedule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Schedule& from);
  void MergeFrom(const Schedule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);

  // optional int32 end = 3;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 3;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:schedule.Schedule)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static Schedule* default_instance_;
};
// -------------------------------------------------------------------

class Tasks : public ::google::protobuf::Message {
 public:
  Tasks();
  virtual ~Tasks();

  Tasks(const Tasks& from);

  inline Tasks& operator=(const Tasks& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tasks& default_instance();

  void Swap(Tasks* other);

  // implements Message ----------------------------------------------

  Tasks* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tasks& from);
  void MergeFrom(const Tasks& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .schedule.Task tasks = 1;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 1;
  inline const ::schedule::Task& tasks(int index) const;
  inline ::schedule::Task* mutable_tasks(int index);
  inline ::schedule::Task* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::schedule::Task >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::schedule::Task >*
      mutable_tasks();

  // optional int32 global_start_time = 2 [default = 0];
  inline bool has_global_start_time() const;
  inline void clear_global_start_time();
  static const int kGlobalStartTimeFieldNumber = 2;
  inline ::google::protobuf::int32 global_start_time() const;
  inline void set_global_start_time(::google::protobuf::int32 value);

  // optional int32 rest_time = 3 [default = 0];
  inline bool has_rest_time() const;
  inline void clear_rest_time();
  static const int kRestTimeFieldNumber = 3;
  inline ::google::protobuf::int32 rest_time() const;
  inline void set_rest_time(::google::protobuf::int32 value);

  // optional int32 max_heap_size = 4 [default = 500000];
  inline bool has_max_heap_size() const;
  inline void clear_max_heap_size();
  static const int kMaxHeapSizeFieldNumber = 4;
  inline ::google::protobuf::int32 max_heap_size() const;
  inline void set_max_heap_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:schedule.Tasks)
 private:
  inline void set_has_global_start_time();
  inline void clear_has_global_start_time();
  inline void set_has_rest_time();
  inline void clear_has_rest_time();
  inline void set_has_max_heap_size();
  inline void clear_has_max_heap_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::schedule::Task > tasks_;
  ::google::protobuf::int32 global_start_time_;
  ::google::protobuf::int32 rest_time_;
  ::google::protobuf::int32 max_heap_size_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static Tasks* default_instance_;
};
// -------------------------------------------------------------------

class Schedules : public ::google::protobuf::Message {
 public:
  Schedules();
  virtual ~Schedules();

  Schedules(const Schedules& from);

  inline Schedules& operator=(const Schedules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Schedules& default_instance();

  void Swap(Schedules* other);

  // implements Message ----------------------------------------------

  Schedules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Schedules& from);
  void MergeFrom(const Schedules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Schedules_FinalStatus FinalStatus;
  static const FinalStatus SUCCESS = Schedules_FinalStatus_SUCCESS;
  static const FinalStatus INCOMPLETE = Schedules_FinalStatus_INCOMPLETE;
  static inline bool FinalStatus_IsValid(int value) {
    return Schedules_FinalStatus_IsValid(value);
  }
  static const FinalStatus FinalStatus_MIN =
    Schedules_FinalStatus_FinalStatus_MIN;
  static const FinalStatus FinalStatus_MAX =
    Schedules_FinalStatus_FinalStatus_MAX;
  static const int FinalStatus_ARRAYSIZE =
    Schedules_FinalStatus_FinalStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FinalStatus_descriptor() {
    return Schedules_FinalStatus_descriptor();
  }
  static inline const ::std::string& FinalStatus_Name(FinalStatus value) {
    return Schedules_FinalStatus_Name(value);
  }
  static inline bool FinalStatus_Parse(const ::std::string& name,
      FinalStatus* value) {
    return Schedules_FinalStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .schedule.Schedule schedules = 1;
  inline int schedules_size() const;
  inline void clear_schedules();
  static const int kSchedulesFieldNumber = 1;
  inline const ::schedule::Schedule& schedules(int index) const;
  inline ::schedule::Schedule* mutable_schedules(int index);
  inline ::schedule::Schedule* add_schedules();
  inline const ::google::protobuf::RepeatedPtrField< ::schedule::Schedule >&
      schedules() const;
  inline ::google::protobuf::RepeatedPtrField< ::schedule::Schedule >*
      mutable_schedules();

  // optional int32 search_steps = 2;
  inline bool has_search_steps() const;
  inline void clear_search_steps();
  static const int kSearchStepsFieldNumber = 2;
  inline ::google::protobuf::int32 search_steps() const;
  inline void set_search_steps(::google::protobuf::int32 value);

  // optional .schedule.Schedules.FinalStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::schedule::Schedules_FinalStatus status() const;
  inline void set_status(::schedule::Schedules_FinalStatus value);

  // repeated string incomplete_tasks = 4;
  inline int incomplete_tasks_size() const;
  inline void clear_incomplete_tasks();
  static const int kIncompleteTasksFieldNumber = 4;
  inline const ::std::string& incomplete_tasks(int index) const;
  inline ::std::string* mutable_incomplete_tasks(int index);
  inline void set_incomplete_tasks(int index, const ::std::string& value);
  inline void set_incomplete_tasks(int index, const char* value);
  inline void set_incomplete_tasks(int index, const char* value, size_t size);
  inline ::std::string* add_incomplete_tasks();
  inline void add_incomplete_tasks(const ::std::string& value);
  inline void add_incomplete_tasks(const char* value);
  inline void add_incomplete_tasks(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& incomplete_tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_incomplete_tasks();

  // optional int32 total_duration = 5;
  inline bool has_total_duration() const;
  inline void clear_total_duration();
  static const int kTotalDurationFieldNumber = 5;
  inline ::google::protobuf::int32 total_duration() const;
  inline void set_total_duration(::google::protobuf::int32 value);

  // optional int32 used_duration = 6;
  inline bool has_used_duration() const;
  inline void clear_used_duration();
  static const int kUsedDurationFieldNumber = 6;
  inline ::google::protobuf::int32 used_duration() const;
  inline void set_used_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:schedule.Schedules)
 private:
  inline void set_has_search_steps();
  inline void clear_has_search_steps();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_total_duration();
  inline void clear_has_total_duration();
  inline void set_has_used_duration();
  inline void clear_has_used_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::schedule::Schedule > schedules_;
  ::google::protobuf::int32 search_steps_;
  int status_;
  ::google::protobuf::RepeatedPtrField< ::std::string> incomplete_tasks_;
  ::google::protobuf::int32 total_duration_;
  ::google::protobuf::int32 used_duration_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static Schedules* default_instance_;
};
// ===================================================================


// ===================================================================

// TimeSegment

// optional int32 duration = 1;
inline bool TimeSegment::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeSegment::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeSegment::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeSegment::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 TimeSegment::duration() const {
  // @@protoc_insertion_point(field_get:schedule.TimeSegment.duration)
  return duration_;
}
inline void TimeSegment::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:schedule.TimeSegment.duration)
}

// optional int32 cool_down = 2 [default = 0];
inline bool TimeSegment::has_cool_down() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeSegment::set_has_cool_down() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeSegment::clear_has_cool_down() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeSegment::clear_cool_down() {
  cool_down_ = 0;
  clear_has_cool_down();
}
inline ::google::protobuf::int32 TimeSegment::cool_down() const {
  // @@protoc_insertion_point(field_get:schedule.TimeSegment.cool_down)
  return cool_down_;
}
inline void TimeSegment::set_cool_down(::google::protobuf::int32 value) {
  set_has_cool_down();
  cool_down_ = value;
  // @@protoc_insertion_point(field_set:schedule.TimeSegment.cool_down)
}

// optional int32 deadline = 3;
inline bool TimeSegment::has_deadline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeSegment::set_has_deadline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeSegment::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeSegment::clear_deadline() {
  deadline_ = 0;
  clear_has_deadline();
}
inline ::google::protobuf::int32 TimeSegment::deadline() const {
  // @@protoc_insertion_point(field_get:schedule.TimeSegment.deadline)
  return deadline_;
}
inline void TimeSegment::set_deadline(::google::protobuf::int32 value) {
  set_has_deadline();
  deadline_ = value;
  // @@protoc_insertion_point(field_set:schedule.TimeSegment.deadline)
}

// repeated int32 earliest_starts = 4;
inline int TimeSegment::earliest_starts_size() const {
  return earliest_starts_.size();
}
inline void TimeSegment::clear_earliest_starts() {
  earliest_starts_.Clear();
}
inline ::google::protobuf::int32 TimeSegment::earliest_starts(int index) const {
  // @@protoc_insertion_point(field_get:schedule.TimeSegment.earliest_starts)
  return earliest_starts_.Get(index);
}
inline void TimeSegment::set_earliest_starts(int index, ::google::protobuf::int32 value) {
  earliest_starts_.Set(index, value);
  // @@protoc_insertion_point(field_set:schedule.TimeSegment.earliest_starts)
}
inline void TimeSegment::add_earliest_starts(::google::protobuf::int32 value) {
  earliest_starts_.Add(value);
  // @@protoc_insertion_point(field_add:schedule.TimeSegment.earliest_starts)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TimeSegment::earliest_starts() const {
  // @@protoc_insertion_point(field_list:schedule.TimeSegment.earliest_starts)
  return earliest_starts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TimeSegment::mutable_earliest_starts() {
  // @@protoc_insertion_point(field_mutable_list:schedule.TimeSegment.earliest_starts)
  return &earliest_starts_;
}

// repeated int32 latest_starts = 5;
inline int TimeSegment::latest_starts_size() const {
  return latest_starts_.size();
}
inline void TimeSegment::clear_latest_starts() {
  latest_starts_.Clear();
}
inline ::google::protobuf::int32 TimeSegment::latest_starts(int index) const {
  // @@protoc_insertion_point(field_get:schedule.TimeSegment.latest_starts)
  return latest_starts_.Get(index);
}
inline void TimeSegment::set_latest_starts(int index, ::google::protobuf::int32 value) {
  latest_starts_.Set(index, value);
  // @@protoc_insertion_point(field_set:schedule.TimeSegment.latest_starts)
}
inline void TimeSegment::add_latest_starts(::google::protobuf::int32 value) {
  latest_starts_.Add(value);
  // @@protoc_insertion_point(field_add:schedule.TimeSegment.latest_starts)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TimeSegment::latest_starts() const {
  // @@protoc_insertion_point(field_list:schedule.TimeSegment.latest_starts)
  return latest_starts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TimeSegment::mutable_latest_starts() {
  // @@protoc_insertion_point(field_mutable_list:schedule.TimeSegment.latest_starts)
  return &latest_starts_;
}

// optional int32 priority = 6 [default = 10];
inline bool TimeSegment::has_priority() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TimeSegment::set_has_priority() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TimeSegment::clear_has_priority() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TimeSegment::clear_priority() {
  priority_ = 10;
  clear_has_priority();
}
inline ::google::protobuf::int32 TimeSegment::priority() const {
  // @@protoc_insertion_point(field_get:schedule.TimeSegment.priority)
  return priority_;
}
inline void TimeSegment::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:schedule.TimeSegment.priority)
}

// -------------------------------------------------------------------

// Task

// optional string id = 1;
inline bool Task::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Task::id() const {
  // @@protoc_insertion_point(field_get:schedule.Task.id)
  return *id_;
}
inline void Task::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:schedule.Task.id)
}
inline void Task::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:schedule.Task.id)
}
inline void Task::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:schedule.Task.id)
}
inline ::std::string* Task::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:schedule.Task.id)
  return id_;
}
inline ::std::string* Task::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:schedule.Task.id)
}

// optional string group = 2;
inline bool Task::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_group() {
  if (group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_->clear();
  }
  clear_has_group();
}
inline const ::std::string& Task::group() const {
  // @@protoc_insertion_point(field_get:schedule.Task.group)
  return *group_;
}
inline void Task::set_group(const ::std::string& value) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_ = new ::std::string;
  }
  group_->assign(value);
  // @@protoc_insertion_point(field_set:schedule.Task.group)
}
inline void Task::set_group(const char* value) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_ = new ::std::string;
  }
  group_->assign(value);
  // @@protoc_insertion_point(field_set_char:schedule.Task.group)
}
inline void Task::set_group(const char* value, size_t size) {
  set_has_group();
  if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_ = new ::std::string;
  }
  group_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:schedule.Task.group)
}
inline ::std::string* Task::mutable_group() {
  set_has_group();
  if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:schedule.Task.group)
  return group_;
}
inline ::std::string* Task::release_group() {
  clear_has_group();
  if (group_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_;
    group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Task::set_allocated_group(::std::string* group) {
  if (group_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_;
  }
  if (group) {
    set_has_group();
    group_ = group;
  } else {
    clear_has_group();
    group_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:schedule.Task.group)
}

// repeated string pre_req_ids = 3;
inline int Task::pre_req_ids_size() const {
  return pre_req_ids_.size();
}
inline void Task::clear_pre_req_ids() {
  pre_req_ids_.Clear();
}
inline const ::std::string& Task::pre_req_ids(int index) const {
  // @@protoc_insertion_point(field_get:schedule.Task.pre_req_ids)
  return pre_req_ids_.Get(index);
}
inline ::std::string* Task::mutable_pre_req_ids(int index) {
  // @@protoc_insertion_point(field_mutable:schedule.Task.pre_req_ids)
  return pre_req_ids_.Mutable(index);
}
inline void Task::set_pre_req_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:schedule.Task.pre_req_ids)
  pre_req_ids_.Mutable(index)->assign(value);
}
inline void Task::set_pre_req_ids(int index, const char* value) {
  pre_req_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:schedule.Task.pre_req_ids)
}
inline void Task::set_pre_req_ids(int index, const char* value, size_t size) {
  pre_req_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:schedule.Task.pre_req_ids)
}
inline ::std::string* Task::add_pre_req_ids() {
  return pre_req_ids_.Add();
}
inline void Task::add_pre_req_ids(const ::std::string& value) {
  pre_req_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:schedule.Task.pre_req_ids)
}
inline void Task::add_pre_req_ids(const char* value) {
  pre_req_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:schedule.Task.pre_req_ids)
}
inline void Task::add_pre_req_ids(const char* value, size_t size) {
  pre_req_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:schedule.Task.pre_req_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Task::pre_req_ids() const {
  // @@protoc_insertion_point(field_list:schedule.Task.pre_req_ids)
  return pre_req_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Task::mutable_pre_req_ids() {
  // @@protoc_insertion_point(field_mutable_list:schedule.Task.pre_req_ids)
  return &pre_req_ids_;
}

// optional .schedule.TimeSegment time = 5;
inline bool Task::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_time() {
  if (time_ != NULL) time_->::schedule::TimeSegment::Clear();
  clear_has_time();
}
inline const ::schedule::TimeSegment& Task::time() const {
  // @@protoc_insertion_point(field_get:schedule.Task.time)
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::schedule::TimeSegment* Task::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::schedule::TimeSegment;
  // @@protoc_insertion_point(field_mutable:schedule.Task.time)
  return time_;
}
inline ::schedule::TimeSegment* Task::release_time() {
  clear_has_time();
  ::schedule::TimeSegment* temp = time_;
  time_ = NULL;
  return temp;
}
inline void Task::set_allocated_time(::schedule::TimeSegment* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
  // @@protoc_insertion_point(field_set_allocated:schedule.Task.time)
}

// -------------------------------------------------------------------

// Schedule

// optional string id = 1;
inline bool Schedule::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Schedule::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Schedule::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Schedule::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Schedule::id() const {
  // @@protoc_insertion_point(field_get:schedule.Schedule.id)
  return *id_;
}
inline void Schedule::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:schedule.Schedule.id)
}
inline void Schedule::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:schedule.Schedule.id)
}
inline void Schedule::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:schedule.Schedule.id)
}
inline ::std::string* Schedule::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:schedule.Schedule.id)
  return id_;
}
inline ::std::string* Schedule::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Schedule::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:schedule.Schedule.id)
}

// optional int32 start = 2;
inline bool Schedule::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Schedule::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Schedule::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Schedule::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 Schedule::start() const {
  // @@protoc_insertion_point(field_get:schedule.Schedule.start)
  return start_;
}
inline void Schedule::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:schedule.Schedule.start)
}

// optional int32 end = 3;
inline bool Schedule::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Schedule::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Schedule::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Schedule::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 Schedule::end() const {
  // @@protoc_insertion_point(field_get:schedule.Schedule.end)
  return end_;
}
inline void Schedule::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:schedule.Schedule.end)
}

// -------------------------------------------------------------------

// Tasks

// repeated .schedule.Task tasks = 1;
inline int Tasks::tasks_size() const {
  return tasks_.size();
}
inline void Tasks::clear_tasks() {
  tasks_.Clear();
}
inline const ::schedule::Task& Tasks::tasks(int index) const {
  // @@protoc_insertion_point(field_get:schedule.Tasks.tasks)
  return tasks_.Get(index);
}
inline ::schedule::Task* Tasks::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:schedule.Tasks.tasks)
  return tasks_.Mutable(index);
}
inline ::schedule::Task* Tasks::add_tasks() {
  // @@protoc_insertion_point(field_add:schedule.Tasks.tasks)
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::schedule::Task >&
Tasks::tasks() const {
  // @@protoc_insertion_point(field_list:schedule.Tasks.tasks)
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::schedule::Task >*
Tasks::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:schedule.Tasks.tasks)
  return &tasks_;
}

// optional int32 global_start_time = 2 [default = 0];
inline bool Tasks::has_global_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tasks::set_has_global_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tasks::clear_has_global_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tasks::clear_global_start_time() {
  global_start_time_ = 0;
  clear_has_global_start_time();
}
inline ::google::protobuf::int32 Tasks::global_start_time() const {
  // @@protoc_insertion_point(field_get:schedule.Tasks.global_start_time)
  return global_start_time_;
}
inline void Tasks::set_global_start_time(::google::protobuf::int32 value) {
  set_has_global_start_time();
  global_start_time_ = value;
  // @@protoc_insertion_point(field_set:schedule.Tasks.global_start_time)
}

// optional int32 rest_time = 3 [default = 0];
inline bool Tasks::has_rest_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tasks::set_has_rest_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tasks::clear_has_rest_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tasks::clear_rest_time() {
  rest_time_ = 0;
  clear_has_rest_time();
}
inline ::google::protobuf::int32 Tasks::rest_time() const {
  // @@protoc_insertion_point(field_get:schedule.Tasks.rest_time)
  return rest_time_;
}
inline void Tasks::set_rest_time(::google::protobuf::int32 value) {
  set_has_rest_time();
  rest_time_ = value;
  // @@protoc_insertion_point(field_set:schedule.Tasks.rest_time)
}

// optional int32 max_heap_size = 4 [default = 500000];
inline bool Tasks::has_max_heap_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Tasks::set_has_max_heap_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Tasks::clear_has_max_heap_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Tasks::clear_max_heap_size() {
  max_heap_size_ = 500000;
  clear_has_max_heap_size();
}
inline ::google::protobuf::int32 Tasks::max_heap_size() const {
  // @@protoc_insertion_point(field_get:schedule.Tasks.max_heap_size)
  return max_heap_size_;
}
inline void Tasks::set_max_heap_size(::google::protobuf::int32 value) {
  set_has_max_heap_size();
  max_heap_size_ = value;
  // @@protoc_insertion_point(field_set:schedule.Tasks.max_heap_size)
}

// -------------------------------------------------------------------

// Schedules

// repeated .schedule.Schedule schedules = 1;
inline int Schedules::schedules_size() const {
  return schedules_.size();
}
inline void Schedules::clear_schedules() {
  schedules_.Clear();
}
inline const ::schedule::Schedule& Schedules::schedules(int index) const {
  // @@protoc_insertion_point(field_get:schedule.Schedules.schedules)
  return schedules_.Get(index);
}
inline ::schedule::Schedule* Schedules::mutable_schedules(int index) {
  // @@protoc_insertion_point(field_mutable:schedule.Schedules.schedules)
  return schedules_.Mutable(index);
}
inline ::schedule::Schedule* Schedules::add_schedules() {
  // @@protoc_insertion_point(field_add:schedule.Schedules.schedules)
  return schedules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::schedule::Schedule >&
Schedules::schedules() const {
  // @@protoc_insertion_point(field_list:schedule.Schedules.schedules)
  return schedules_;
}
inline ::google::protobuf::RepeatedPtrField< ::schedule::Schedule >*
Schedules::mutable_schedules() {
  // @@protoc_insertion_point(field_mutable_list:schedule.Schedules.schedules)
  return &schedules_;
}

// optional int32 search_steps = 2;
inline bool Schedules::has_search_steps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Schedules::set_has_search_steps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Schedules::clear_has_search_steps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Schedules::clear_search_steps() {
  search_steps_ = 0;
  clear_has_search_steps();
}
inline ::google::protobuf::int32 Schedules::search_steps() const {
  // @@protoc_insertion_point(field_get:schedule.Schedules.search_steps)
  return search_steps_;
}
inline void Schedules::set_search_steps(::google::protobuf::int32 value) {
  set_has_search_steps();
  search_steps_ = value;
  // @@protoc_insertion_point(field_set:schedule.Schedules.search_steps)
}

// optional .schedule.Schedules.FinalStatus status = 3;
inline bool Schedules::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Schedules::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Schedules::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Schedules::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::schedule::Schedules_FinalStatus Schedules::status() const {
  // @@protoc_insertion_point(field_get:schedule.Schedules.status)
  return static_cast< ::schedule::Schedules_FinalStatus >(status_);
}
inline void Schedules::set_status(::schedule::Schedules_FinalStatus value) {
  assert(::schedule::Schedules_FinalStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:schedule.Schedules.status)
}

// repeated string incomplete_tasks = 4;
inline int Schedules::incomplete_tasks_size() const {
  return incomplete_tasks_.size();
}
inline void Schedules::clear_incomplete_tasks() {
  incomplete_tasks_.Clear();
}
inline const ::std::string& Schedules::incomplete_tasks(int index) const {
  // @@protoc_insertion_point(field_get:schedule.Schedules.incomplete_tasks)
  return incomplete_tasks_.Get(index);
}
inline ::std::string* Schedules::mutable_incomplete_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:schedule.Schedules.incomplete_tasks)
  return incomplete_tasks_.Mutable(index);
}
inline void Schedules::set_incomplete_tasks(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:schedule.Schedules.incomplete_tasks)
  incomplete_tasks_.Mutable(index)->assign(value);
}
inline void Schedules::set_incomplete_tasks(int index, const char* value) {
  incomplete_tasks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:schedule.Schedules.incomplete_tasks)
}
inline void Schedules::set_incomplete_tasks(int index, const char* value, size_t size) {
  incomplete_tasks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:schedule.Schedules.incomplete_tasks)
}
inline ::std::string* Schedules::add_incomplete_tasks() {
  return incomplete_tasks_.Add();
}
inline void Schedules::add_incomplete_tasks(const ::std::string& value) {
  incomplete_tasks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:schedule.Schedules.incomplete_tasks)
}
inline void Schedules::add_incomplete_tasks(const char* value) {
  incomplete_tasks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:schedule.Schedules.incomplete_tasks)
}
inline void Schedules::add_incomplete_tasks(const char* value, size_t size) {
  incomplete_tasks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:schedule.Schedules.incomplete_tasks)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Schedules::incomplete_tasks() const {
  // @@protoc_insertion_point(field_list:schedule.Schedules.incomplete_tasks)
  return incomplete_tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Schedules::mutable_incomplete_tasks() {
  // @@protoc_insertion_point(field_mutable_list:schedule.Schedules.incomplete_tasks)
  return &incomplete_tasks_;
}

// optional int32 total_duration = 5;
inline bool Schedules::has_total_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Schedules::set_has_total_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Schedules::clear_has_total_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Schedules::clear_total_duration() {
  total_duration_ = 0;
  clear_has_total_duration();
}
inline ::google::protobuf::int32 Schedules::total_duration() const {
  // @@protoc_insertion_point(field_get:schedule.Schedules.total_duration)
  return total_duration_;
}
inline void Schedules::set_total_duration(::google::protobuf::int32 value) {
  set_has_total_duration();
  total_duration_ = value;
  // @@protoc_insertion_point(field_set:schedule.Schedules.total_duration)
}

// optional int32 used_duration = 6;
inline bool Schedules::has_used_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Schedules::set_has_used_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Schedules::clear_has_used_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Schedules::clear_used_duration() {
  used_duration_ = 0;
  clear_has_used_duration();
}
inline ::google::protobuf::int32 Schedules::used_duration() const {
  // @@protoc_insertion_point(field_get:schedule.Schedules.used_duration)
  return used_duration_;
}
inline void Schedules::set_used_duration(::google::protobuf::int32 value) {
  set_has_used_duration();
  used_duration_ = value;
  // @@protoc_insertion_point(field_set:schedule.Schedules.used_duration)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace schedule

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::schedule::Schedules_FinalStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::schedule::Schedules_FinalStatus>() {
  return ::schedule::Schedules_FinalStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_task_2eproto__INCLUDED
